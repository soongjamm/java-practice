# IoC/DI (Inversion of Control / Dependency Injection)

## 의존성이란?
`의사코드`
- 운전자가 자동차를 생산한다.
- 자동차는 내부적으로 타이어를 생산한다.

`자바로 표현`
- new Car();
- Car 객체의 생성자 안에 new Tire();

의존성을 정리하면
- 의존성은 new
- new를 실행하는 Car와 Tire 사이에서 Car가 Tire에 의존
- `전체와 부분` - 전체가 부분에 의존한다.
    - 전체 : Car
    - 부분 : Tire
- `프로그래밍에서 의존 관계는 new로 표현된다.`

> 기존 자바 코드로만 표현하면
> main()에서 Car car = new Car(); 로 Car 객체를 생성하고
> Car의 생성자 내부에서 Tire tire = new Tire(); 로 타이어를 생성함으로써 의존성을 표현한다.
> == 의존성을 자체적으로 해결한다.


## 스프링 없이 의존성 주입1 - 생성자를 통한 의존성 주입
> 주입이란 `외부에서` 라는 뜻을 내포한다.  
> 외부에서 타이어를 생산하고 이미 생산된 자동차에 장착하는 작업이 `주입`이다.  
> 자동차 내부에서 타이어를 생산하지 않는다.
- Car 생성자의 인자로 Tire를 주입하는 형태다.
- 주입하지 않았을 때 기존 코드의 문제점
    - 주입하지 않는 기존 코드에서는 Car가 구체적으로 어떤 Tire를 생산할지 결정했다.
    - 그러므로 유연성이 떨어진다.
    - Car가 KoreaTire, AmericaTire에 대해 정확하게 알아야만 객체를 생성할 수 있었다.
- 장점
    - 자동차가 스스로 고민하지 않고, 운전자가 차량을 자동차를 생산할 때 고민한다.
    - 구체적인 Tire의 정보가 없어도 Tire 인터페이스를 구현한 객체라면 정상적으로 작동한다.
    - 즉 새로운 브랜드의 타이어가 생겨도 Tire 인터페이스를 구현하기만 한다면 코드를 변경할 필요가 없다.
        - 다시 컴파일하지 않아도 된다.
        - Car.java, Tire.java를 하나의 모듈로, Driver.java, KoreaTire.java .. 를 하나의 모듈로 한다면
        - 새로운 타이어가 생겨도 Driver.java, ChinaTire.java만 컴파일해서 배포하면 된다.
    - 이것을 현실세계에서의 말로 `표준화`했다고 한다.

> 전략 패턴을 사용하고 있다.
> 전략 - 각종 타이어들
> 컨텍스트 - Car의 getTireBrand()
> 클라이언트 - Driver의 main() 

## 스프링 없이 의존성 주입2 - 속서을 통한 의존성 주입
- 속성(setter)로 Tire를 주입하는 형태다.
- 생성자로 의존성을 주입했을 때 문제점
    - 타이어를 장착하고 나면 바꿀 수 없다.